#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Trajet {
    int id;             // Identifiant du trajet
    float distance_min; // Distance minimale
    float distance_max; // Distance maximale
    float distance_sum; // Somme des distances
    int usage_count;    // Nombre d'utilisations
    struct Trajet *left;
    struct Trajet *right;
} Trajet;

Trajet *creerTrajet(int id, float distance) {
    Trajet *nouveauTrajet = (Trajet *)malloc(sizeof(Trajet));
    if (nouveauTrajet == NULL) {
        fprintf(stderr, "Erreur d'allocation de mémoire.\n");
        exit(EXIT_FAILURE);
    }

    nouveauTrajet->id = id;
    nouveauTrajet->distance_min = distance;
    nouveauTrajet->distance_max = distance;
    nouveauTrajet->distance_sum = distance;
    nouveauTrajet->usage_count = 1;
    nouveauTrajet->left = NULL;
    nouveauTrajet->right = NULL;

    return nouveauTrajet;
}

int max(int a, int b) {
    return (a > b) ? a : b;
}

int min(int a, int b) {
    return (a < b) ? a : b;
}

int max2(int a, int b, int c) {
    return max(max(a, b), c);
}

int min2(int a, int b, int c) {
    return min(min(a, b), c);
}

Trajet *rotationG(Trajet *a) {
    Trajet *pivot = a->fd;
    a->fd = pivot->fg;
    pivot->fg = a;
    int eq_a = a->equilibre;
    int eq_pivot = pivot->equilibre;
    a->equilibre = eq_a - max(eq_pivot, 0) - 1;
    pivot->equilibre = min2(eq_a - 2, eq_a + eq_pivot - 2, eq_pivot - 1);
    a = pivot;
    return a;
}

Trajet *rotationD(Trajet *a) {
    Trajet *pivot = a->fg;
    a->fg = pivot->fd;
    pivot->fd = a;
    int eq_a = a->equilibre;
    int eq_pivot = pivot->equilibre;
    a->equilibre = eq_a - min(eq_pivot, 0) + 1;
    pivot->equilibre = max2(eq_a + 2, eq_a + eq_pivot + 2, eq_pivot + 1);
    a = pivot;
    return a;
}

Trajet *DoubleRG(Trajet *a) {
    a->fd = rotationD(a->fd);
    return rotationG(a);
}

Trajet *DoubleRD(Trajet *a) {
    a->fg = rotationG(a->fg);
    return rotationD(a);
}

Trajet *equilibreAVL(Trajet *a) {
    if (a->equilibre >= 2) {
        if (a->fd->equilibre >= 0) {
            return rotationG(a);
        } else {
            return DoubleRG(a);
        }
    } else if (a->equilibre <= -2) {
        if (a->fg->equilibre <= 0) {
            return rotationD(a);
        } else {
            return DoubleRD(a);
        }
    }
    return a;
}

Trajet *insererTrajetById(Trajet *racine, int id, float distance, int *h) {
    if (racine == NULL) {
    *h = 1;
        return creerTrajet(id, distance);
    }

    if (id < racine->id) {
        racine->left = insererTrajetById(racine->left, id, distance, h);
        *h = -*h;
    } else if (id > racine->id) {
        racine->right = insererTrajetById(racine->right, id, distance, h);
    } else {
        mettreAJourTrajet(racine, distance);
        *h = 0;
    }

    if (*h != 0) {
        racine->equilibre = racine->equilibre + *h;
        racine = equilibreAVL(racine);
        if (racine->equilibre == 0) {
            *h = 0;
        } else {
            *h = 1;
        }
    }

    return racine;
}

// Fonction pour insérer un trajet dans l'AVL trié par différence maxi - mini
Trajet *insererTrajetByDifference(Trajet *racine, int id, float distance, int *h) {
    if (racine == NULL) {
    *h = 1;
        return creerTrajet(id, distance);
    }

    float difference = racine->distance_max - racine->distance_min;
    float new_difference = distance - racine->distance_min;

    if (new_difference < difference) {
        racine->left = insererTrajetByDifference(racine->left, id, distance, h);
        *h = -*h;
    } else if (new_difference > difference) {
        racine->right = insererTrajetByDifference(racine->right, id, distance, h);
    }
    else {
    	*h = 0;
    	}

    if (*h != 0) {
        racine->equilibre = racine->equilibre + *h;
        racine = equilibreAVL(racine);
        if (racine->equilibre == 0) {
            *h = 0;
        } else {
            *h = 1;
        }
    }

    return racine;
}



Trajet *copierTrajet(Trajet *av1, Trajet *av2) {
int h = 0;
    if (av1 != NULL) {
        av2 = insererTrajetByDifference(av2, av1->id, av1->distance_max - av1->distance_min, &h);
        copierTrajet(av1->left, av2);
        copierTrajet(av1->right, av2);
    }

    return av2;
}


void mettreAJourTrajet(Trajet *trajet, float distance) {
    trajet->usage_count++;
    trajet->distance_sum += distance;

    if (distance < trajet->distance_min) {
        trajet->distance_min = distance;
    }

    if (distance > trajet->distance_max) {
        trajet->distance_max = distance;
    }
}


void afficherTop50(Trajet *racine, int *compteur) {
    if (racine != NULL && *compteur > 0) {
        afficherTop50(racine->right, compteur);

       
        printf("ID: %d | Min: %.2f | Max: %.2f | Moyenne: %.2f | Utilisations: %d\n",
               racine->id, racine->distance_min, racine->distance_max,
               racine->distance_sum / racine->usage_count, racine->usage_count);

        (*compteur)--;

        afficherTop50(racine->left, compteur);
    }
}



void libererAVL(Trajet *racine) {
    if (racine != NULL) {
        libererAVL(racine->left);
        libererAVL(racine->right);
        free(racine);
    }
}

void Tri_s() {
    int h = 0;
    FILE *fichier = fopen("data.csv", "r");
    if (fichier == NULL) {
        fprintf(stderr, "Erreur lors de l'ouverture du fichier.\n");
        exit(EXIT_FAILURE);
    }
    
    

    Trajet *avl = NULL;
    Trajet *avl2 = NULL;

    int id;
    float distance;

    while (fscanf(f, "%d;%f\n", &id, &distance) == 2) {
        avl = insererTrajetById(avl, id, distance, &h);
        avl2 = copierTrajet(avl, avl2);
    }

    fclose(f);

    
    int compteur = 50;
    afficherTop50(avl2, &compteur);

    
    libererAVL(avl);
    libererAVL(avl2);

    fclose(fichier);
}


int main() {
	Tri_s();
    return 0;
}
